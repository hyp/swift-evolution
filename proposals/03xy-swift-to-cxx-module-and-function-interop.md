# Bridging Swift modules and top-level functions to C++

*   Proposal: [SE-03xy](03xy-swift-to-cxx-module-and-function-interop.md)
*   Authors: [Alex Lorenz](https://github.com/hyp)
*   Review Manager:
*   Status: 
*   Implementation: <TODO> Implemented on main as experimental feature (requires `-enable-experimental-cxx-interop` flag)

## Introduction

Swift-to-C++ interoperability requires C++ code to import Swift APIs into C++ in order
to be able to call them. Per the [vision document](), Swift-to-C++ interoperability feature is modeled
on the existing Objective-C interoperability feature, as it uses the same generated header file in order to represent Swift APIs of a specific Swift module in C++. This proposal presents this header-based user model for Swift-to-C++ interoperability and talks about how it differs to the user model of Objective-C interoperability. It also describes how Swift module namespacing is handled when Swift APIs are bridged to C++. Finally, this proposal describes how top-level synchronous Swift functions that use primitive types in their signature are represented in the C++ section of the generated header file.

This proposal is the initial proposal for Swift-to-C++ interoperability feature of Swift. As such, it builds a foundation which future proposals will use to describe how different Swift language constructs and API patterns get mapped to C++.

## Proposed solution

Emit C++ declarations that wrap around the underlying calls to Swift APIs or provide
representation for Swift types in a new C++ section of the header file that's generated by the Swift compiler to
represent the C/Objective-C/C++ interface for a specific Swift module.
Rename the existing `-emit-objc-header` Swift compiler flag to `-emit-clang-header`, while keeping the old name for compatibility with existing build systems and makefiles. The new flag name makes it more clear
that the header file that Swift generates provides interface for Clang-based languages like Objective-C, C and C++, instead of just providing an Objective-C-based interface for a Swift module.

Map each Swift module to a C++ `namespace` declaration to provide namespacing for Swift APIs in C++.

### Header generation

The Swift compiler generates a header file with C/Objective-C/C++ representation of
the exposed APIs in the Swift module when the `-emit-clang-header` flag is used. (`-emit-objc-header`).
The compiler can generate such header from different inputs:
- Swift module source files
- Serialized Swift module file
- Textual Swift module interface file

The header file contains different sections, that provide representation for the exposed
APIs in different language modes. The following sections can be present in the header:
- C-compatible section: This section contains C function stubs that represent exposed Swift functions. They are annotated with the appopriate ABI and calling convention attributes.
- Objective-C section: This section provides representation for the `@objc` declarations. Its content is identical to the Objective-C content in the header that was emitted with the currently supported `-emit-objc-header` flag.
- C++ section: This section provides representation for the exposed Swift declarations that are representable in C++.
- Objective-C++ section: This section provides additional glue code to connect declarations in the Objective-C and C++ sections, or additional APIs for emitted C++ types in Objective-C++.
 
Each language-specific section is guarded with appropriate preprocessor guards to ensure
that the translation unit that includes this header will only see the declarations that are
supported in the language mode that's used to build it. Here's an example <TODO>:

```c++
// This section contains raw C stubs annotated with appropriate ABI attributes for Swift functions.

#ifdef __OBJC__
  // This section contains exposed `@objc` declarations.
#endif

#ifdef __cplusplus
  // This section contains exposed Swift declarations that are representable in C++.

  #ifdef __OBJC__
    // This section contains any Objective-C++ specific glue code and API enhancements.
  #endif
#endif
```

This proposal focuses on the C-compatible and the C++ sections of the header file
when describing how top-level Swift functions are represented in the header.

#### C++ interoperability is opt-out not opt-in

Declarations are laid out the header. Header is eagerly generated, so everything that's exposed.

