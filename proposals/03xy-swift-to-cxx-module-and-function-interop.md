# Bridging Swift modules and top-level functions to C++

*   Proposal: [SE-03xy](03xy-swift-to-cxx-module-and-function-interop.md)
*   Authors: [Alex Lorenz](https://github.com/hyp)
*   Review Manager:
*   Status: 
*   Implementation: <TODO> Implemented on main as experimental feature (requires `-enable-experimental-cxx-interop` flag)

## Introduction

Swift-to-C++ interoperability requires C++ code to import Swift APIs into C++ in order
to be able to call them. Per the [vision document](TODO), Swift-to-C++ interoperability feature is modeled
on the existing Objective-C interoperability feature, as it uses the same generated header file in order to represent Swift APIs of a specific Swift module in C++. This proposal presents this header-based user model for Swift-to-C++ interoperability and talks about how it differs to the user model of Objective-C interoperability. It also describes how Swift module namespacing is handled when Swift APIs are bridged to C++. Finally, this proposal describes how top-level synchronous Swift functions that use primitive types in their signature are represented in the C++ section of the generated header file.

This proposal is the initial proposal for Swift-to-C++ interoperability feature of Swift. As such, it builds a foundation which future proposals will use to describe how different Swift language constructs and API patterns get mapped to C++. Certain design decisions presented in the proposal will be revisited in the future, <TODO: specific list>, and as such this proposal does not present the final design for the foundation layer of Swift-to-C++ interoperability.

Swift-evolution thread: [Pitch #1](TODO)

## Proposed solution

Emit C++ declarations that wrap around the underlying calls to exposed Swift APIs or provide
representation for exposed Swift types in a new C++ section of the header file that's generated by the Swift compiler to
represent the C/Objective-C/C++ interface for a specific Swift module.

Rename the existing `-emit-objc-header` Swift compiler flag to `-emit-clang-header`, while keeping the old name for compatibility with existing build systems and makefiles. The new flag name makes it more clear
that the header file that Swift generates provides interface for Clang-based languages like Objective-C, C and C++, instead of just providing an Objective-C-based interface for a Swift module.

Map each Swift module to a C++ `namespace` declaration to provide namespacing for Swift APIs in C++.

TODO: Describe your solution to the problem. Provide examples and describe how they work. Show how your solution is better than current workarounds: is it cleaner, safer, or more efficient?


### Header generation

The Swift compiler generates a header file with C/Objective-C/C++ representation of
the exposed APIs in the Swift module when the `-emit-clang-header` flag is used. (`-emit-objc-header`).
The compiler can generate such header from different inputs:
- Swift module source files
- Serialized Swift module file
- Textual Swift module interface file

#### Mixing different languages in single header

The header file contains different sections, that provide representation for the exposed
APIs in different language modes. The following sections can be present in the header:
- C section: Contains C function declarations with appropriate ABI annotations that represent exposed Swift functions.
- Objective-C section: Provides representation for the `@objc` declarations. Its content is identical to the Objective-C content in the header that was emitted with the currently supported `-emit-objc-header` flag.
- C++ section: Provides representation for the exposed Swift declarations that are representable in C++.
- Objective-C++ section: Provides additional glue code to connect declarations in the Objective-C and C++ sections, or additional APIs for emitted C++ types in Objective-C++.
 
Each language-specific section is guarded with appropriate preprocessor guards to ensure
that the translation unit that includes this header will only see the declarations that are
supported in the language mode that's used to build it. Here's an example <TODO>:

```c++
// This section contains C declarations annotated with appropriate ABI attributes for Swift functions.

#ifdef __OBJC__
  // This section contains exposed `@objc` declarations.
#endif

#ifdef __cplusplus
  // This section contains exposed Swift declarations that are representable in C++.

  #ifdef __OBJC__
    // This section contains any Objective-C++ specific glue code and API enhancements.
  #endif
#endif
```

This proposal focuses on the C-compatible and the C++ sections of the header file
when describing how top-level Swift functions are represented in the header.

#### C++ interoperability is opt-out not opt-in

Declarations are laid out the header. Header is eagerly generated, so everything that's exposed.

The user model employed by Swift-to-C++ interoperability is different than the user model employed by the Objective-C interoperability. C++ can use Swift's native calling convention when calling Swift functions, and C++ does not have restrictions on what Swift types it can work with. This means that Swift APIs do not require additional annotations when they're bridged to C++. This fact highlights the key difference between C++ and Objective-C interoperability; Swift library author is not required to change their code when their APIs are exposed to C++, whereas they are required to opt-in into interoperability using an @objc annotation when exposing APIs to Objective-C. Swift library authors will still be able to opt-out from exposing certain APIs to C++ when they desire to do so.

Swift module author is not required to annotate their Swift declarations with attributes
like `@objc` when exposing Swift APIs to C++. This means that the client that
wants to import such Swift APIs into C++ can generate a header file that contains the
C++ representation of these Swift APIs from the Swift module or module interface file on their own.
As such,

#### Which Swift APIs get exposed to C++

The initial user model presented in this proposal intentionally limits the set of Swift APIs
exposed to C++. This decision allows early adopters of Swift-to-C++ interoperability
to have precise control of the generated C++ interface. The experimental implementation
requires that the APIs that the Swift API author wants to expose to C++ are annotated with the [experimental `@expose` attribute](https://forums.swift.org/t/formalizing-cdecl/40677/50) <TODO is this good>.
This attribute will be pitched to Swift evolution in a future proposal. Since this attribute
is not covered by this proposal, the Swift code samples presented in this proposal omit it from
the Swift declarations in those samples.

As the support for Swift-to-C++ interoperability improves, it will become possible
to expose any public Swift API in a Swift module as long as it's actually
representable in C++. As such, the decision to require an explicit annotation
to expose a Swift API to C++ might be revisited in the future.

#### Generated header name

Swift users can choose the file name of the generated
header using the `-emit-clang-header-path` flag. The recommended naming
scheme for such header file follows the currently recommended naming scheme
for Objective-C headers, i.e. `ModuleName-Swift.h"`. This recommended naming
scheme might get revisited in the future.

### Module namespacing in C++

The generated C++ code that represents exposed Swift APIs in a module is placed
into a C++ `namespace` declaration. The name of the `namespace` declaration is
identical to the Swift module name. For example, a Swift module `SwiftForTheWin`
maps to a C++ namespace with the same name, as represented by this sample snippet
from the generated header file:

```
#ifdef __cplusplus

namespace SwiftForTheWin {

// C++ declarations representing Swift APIs in the 'SwiftForTheWin' module.

} // namespace SwiftForTheWin

#endif // __cplusplus
```

#### The Swift standard library module

The Swift standard library module uses a different naming scheme for its corresponding C++
namespace. Instead of using the original `Swift` module name, its corresponding C++
namespace uses `swift` name instead. The use of lowercase name here makes it
easier to access Swift APIs like `Array` in a consistent manner with C++ conventions.
